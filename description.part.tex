% !TEX root = prop.tex
%%% Project Description
%\clearpage
\setcounter{page}{1}
\rfoot{\scriptsize\textsf{\thepage}}

%\noindent{\Large\bf Project Description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project Objectives}
\label{sec:objectives}

% IDE vs Editor
% Development Environment

% Action Semantics for IDE
% ==> Action Semantics for Editor

% Edit State = History of all previous edit/debugging actions
% - AST with a focus
% - Debugger

% Computed from Edit State
% - Suggestions
% - History
% - Predictions

% vs ipython:
% - Editing code
% - Code completion

% vs conventional IDEs:
% -



This proposal aims to bridge two historically divided traditions: (1) the formal
tradition, which has produced seminal advances by viewing programming languages,
and therefore programs, as mathematical structures~\cite{pfpl,Pierce:2002hj}; and (2) the design
tradition, which has produced a number of innovative interactive programming
tools by viewing programming as an interaction between a human programmer and a
tool. We borrow from both views to propose \HazelEnv: a clean-slate interactive programming
environment equipped with a formal semantics that assigns meaning 
to ``edit-time'' structures and interactions that have largely been 
considered beyond the scope of the formal tradition to date. Figure~\ref{fig:hazel-mockup} shows a mockup of \HazelEnv's user interface,
which we will reference throughout this discussion.

\HazelEnv, like many existing language-specific program editors (e.g. Eclipse
and Emacs, with the appropriate  
extensions installed \cite{gamma2004contributing}), will provide a number of standard editor services, including (1)
syntax highlighting, (2)
the ability to inspect the type of an expression, (3)
the ability to jump to the binding site of a variable, and (4)
the ability to rename a variable in a semantics-preserving manner. 
Were \HazelEnv to encounter only \emph{complete programs}, it would be clear how
to proceed. For example, a syntax highlighter could automatically be produced
from a lightly annotated version of the context-free syntax of the
language \cite{DBLP:conf/tools/KrahnRV08,DBLP:conf/cc/BrandDHJJKKMOSVVV01}. The remaining editor services could be implemented
by following the language's type and binding structure, as specified by a formal
semantics. The problem that animates this proposal is that the
editor must confront many \emph{edit states} that do not map onto complete
programs.

\vspace{0.25ex}
\noindent\textbf{Problem 1: Syntactically Malformed Edit States.} 
Textual program editors frequently encounter edit states
that are not well-formed with respect to the textual syntax of complete
programs. For example, consider a programmer in the midst of
constructing a call to a function \lstinline{std}: 

$\texttt{std(y, }$

There is a syntax
error at this moment in the editing process, so editor services that require a syntactically
complete program must be disabled. This is unsatisfying. Sophisticated editors like Eclipse, and editor generators like Spoofax \cite{DBLP:conf/oopsla/KatsV10}, use \emph{error recovery} heuristics that can support the continued provision 
of various services in some formally malformed states, by using secondary notational conventions (e.g. whitespace) to segregate malformed portions of the program  \cite{DBLP:conf/oopsla/KatsJNV09,DBLP:conf/sle/JongeNKV09}. These heuristics work most, but not all, of the time.

The alternative approach that we take for \HazelEnv is to build a
\emph{structure editor} -- a program editor where every edit state
maps onto a syntax tree, with \emph{holes} representing leaves of the tree
that have not yet been constructed.  This representation choice sidesteps the
problem of syntactically malformed edit states. Notice that in
Figure~\ref{fig:hazel-mockup}, the program fragment in cell
\textbf{(a)} contains holes, appearing as squares. This design also permits
non-textual \emph{projections} of expression, e.g. 
the 2D projection of a matrix value in cell \textbf{(b)}.
We will return to the topic of structure editors and projections below.


\begin{figure}
\includegraphics[width=\textwidth]{mockup-1}
\caption{A mockup of \HazelEnv.}
\label{fig:hazel-mockup}
\vspace{-2ex}
\end{figure}

\vspace{0.25ex}
\noindent\textbf{Problem 2: Statically Meaningless Edit States.} Regardless of how an 
editor confronts syntactically malformed edit states, it must also confront 
edit states that are syntactically well-formed but statically meaningless. For
example, the following value binding has a type inconsistency:
\begin{lstlisting}[numbers=none]
val x : string = std(m, ColumnWise)
\end{lstlisting}
(because \li{std} has type \li{matrix<float> * dimension -> vec<float>},
but the type annotation on \li{x} is \li{string}.) This leaves the entire program
formally meaningless according to a standard static semantics.

In the presence of holes, the problem of reasoning statically about edit states
becomes even more interesting.  Consider the incomplete expression \lstinline{std(m, #$\square$#)} 
from cell \textbf{(a)} in Figure \ref{fig:hazel-mockup}.
%
%\begin{lstlisting}[numbers=none]
%std(m, #$\square$#)
%\end{lstlisting}
%
Although it is apparent that the type of this expression, after hole instantiation, could only be \lstinline{vec<float>} (the return type of \lstinline{std}),
and that the hole must be instantiated with values of type \li{dimension}, the static
semantics of complete expressions is again silent about these matters. 

Various heuristic
approaches are implemented in Eclipse and other sophisticated tools, but the 
formal character of these heuristics are obscure, buried deep within their implementations. This brings us to our first specific research aim: the 
development, from type-theoretic first principles, of \textbf{a static semantics for incomplete programs} (Section~\ref{sec:statics}),
i.e. programs that contain holes, type inconsistencies, unbound variables, and
other static problems. Using such a semantics, \HazelEnv can 
communicate to the programmer (see right column of Figure \ref{fig:hazel-mockup}) that the expression at the cursor, highlighted in blue in cell \textbf{(a)}, must be of type \li{dimension}. The incomplete function
\li{summary_stats} as a whole will be assigned the following incomplete function
type: \texttt{matrix<float> -> \{ {mean} : vec<float>, std : vec<float>, median :~$\square$ \}}.

\vspace{0.25ex}
\noindent\textbf{Problem 3: Dynamically Meaningless Edit States.} Modern programming
tools are increasingly moving beyond simple ``batch'' programming models by
incorporating \emph{live programming} features that interleave editing and
evaluation \cite{DBLP:conf/icse/Tanimoto13,DBLP:journals/vlc/Tanimoto90,McDirmid:2007:LUL:1297105.1297073}. These tools provide programmers with more rapid feedback about the
dynamic behavior of the program they are editing, or selected portions thereof \cite{McDirmid:2013:ULP:2509578.2509585}. Examples include \emph{lab notebooks},
e.g. the popular IPython/Jupyter~\cite{Perez:2007:ISI:1251563.1251831}, which allow the
programmer to interactively edit and evaluate program fragments organized into a
sequence of cells (an extension of the read-eval-print loop (REPL)); spreadsheets; {live graphics programming environments}, e.g. SuperGlue \cite{McDirmid:2007:LUL:1297105.1297073}, Sketch-n-Sketch \cite{DBLP:conf/pldi/ChughHSA16,DBLP:conf/icse/Chugh25} and the tools demonstrated by Bret Victor in his lectures \cite{victor2012inventing}; the TouchDevelop live UI framework \cite{burckhardt2013s}; and live visual and auditory dataflow languages \cite{DBLP:conf/vl/BurnettAW98}. 
% \item \emph{Live debuggers} allow the programmer to:
%   \begin{itemize}
%   \item insert breakpoints, which pause evaluation; 
%   \item step through evaluation one step at a time; 
%   \item inspect the run-time state of a paused program by ``watching'' expressions; and 
%   \item edit the program and resume evaluation in certain circumstances. 
%   \end{itemize}

Our proposed design for \HazelEnv combines aspects of several of these designs to form a \emph{live lab notebook interface}. 
It will use the edit state of each cell to continuously update the output
value displayed for that cell and subsequent cells that depend on
it. Uniquely, rather than providing meaningful feedback about the dynamic
behavior only once a cell becomes complete, \HazelEnv will provide meaningful feedback also
about the dynamic behavior of incomplete cells (and thereby further tighten the live programming 
feedback loop.)

For example, in cell \textbf{(c)} of Figure~\ref{fig:hazel-mockup}, the
programmer applies  the incomplete function \li{summary_stats} to 
the matrix \lstinline{my_data}, and 
the editor is still able to display a result.
The value of the column-wise mean is fully determined, because evaluation does
not encounter any holes, whereas the standard deviation and median computations
cannot be fully evaluated. Notice, however, that the standard
deviation computation does communicate the substitution of the applied argument,
\li{my_data}, for the variable \li{m}.\footnote{To avoid exposing the internals
of imported library functions, evaluation does not step into functions, like
\li{std}, that have been imported from external libraries indicated by the row at the top of Figure \ref{fig:hazel-mockup} (unless specifically
requested, not shown.)}

This brings us to our second specific aim: a
\textbf{dynamic semantics for incomplete programs} (Section~\ref{sec:dynamics}) that builds upon our proposed
static semantics. There is some precedent for this: research in gradual typing
considers the dynamic semantics of programs with holes in types, and indeed, our
proposed static semantics for incomplete programs borrows technical machinery
from theoretical work on gradual typing~\cite{Siek06a}. We seek a dynamic semantics for the
other classes of incomplete programs that we will consider as well.

This will require great formal care, because the presence of type
and binding errors would violate the usual notions of type safety. As such we plan to develop a \emph{mechanized
  metatheory}~\cite{Lee:2007:TMM:1190216.1190245}: we will use a proof assistant to mechanize the semantics and
accompanying metatheorems that establish essential properties, e.g. that
evaluating a statically meaningful incomplete programs will not ``go wrong'' (which we take in
the sense of Milner to mean that it will not have undefined behavior~\cite{milner1978theory,pfpl}).
This represents the ``gold standard'' for evaluating claims in formal
semantics.  Our preliminary work has used Agda~\cite{norell2009dependently}.

\vspace{0.25ex}
\noindent\textbf{Problem 4: Meaningless Edit Actions.} Our first two specific aims
allow us to assign meaning to intermediate edit states. However, to
understand the act of \emph{editing} itself, we propose to develop a system of
\emph{edit actions} that governs transitions between edit
states. Our goal is for every intermediate edit state to be both statically and
dynamically meaningful according to the semantics developed in the first two
specific aims. This corresponds formally to proving a
metatheorem about the action semantics: when the initial edit state is
semantically meaningful, the edit state that results from performing an action
is as well. In addition to this crucial metatheorem, which
we call \emph{sensibility}, there are a number of other metatheorems of interest
that establish the interactive expressive power of the action semantics. Our third specific
aim is thus to develop a sensible and expressive \textbf{semantics of edit actions} (Section~\ref{sec:actions})
and, as above, to mechanize its metatheory.

Designing the static semantics of \HazelEnv together with its action semantics 
will also allow us to rigorously investigate a number of novel constructs that 
are defined with libraries but control aspects of the editor. In particular, we aim to explore:
(1) \textbf{user-defined action macros}, which allow libraries to define new high-level
actions built atop the primitive action language of \HazelEnv; (2) \textbf{type-specific
projections}, which give library providers the ability to define type-specific structure editors (e.g. the matrix interface in Figure \ref{fig:hazel-mockup}, which is defined  
by the \li{Numerics} library); and (3) an \textbf{interactive semantic documentation system} that
allows programmers to document programs by revealing and commenting on portions of the 
program in sequence. Each intermediate state during these ``tutorials'' can be explored 
by the learner, due to the sensibility invariant. The comments can mention bindings, and are 
subject to static operations like renaming.

\vspace{0.25ex}
\noindent\textbf{Problem 5: Meaningless and Improbable Suggestions.} The simplest 
edit actions will be bound to keyboard shortcuts (studies suggest that programmers experienced with a keyboard-driven structure editors can be highly productive \cite{DBLP:conf/vl/Asenov014}). However, \HazelEnv will 
also present a search-based user
interface for discovering relevant higher-level actions -- marked with \textbf{(d)} in Figure \ref{fig:hazel-mockup}. 
The suggestions 
listed are informed by the semantics at the cursor, i.e. they use the fact that
the type at the cursor is \li{dimension} to suggest the two constructors of that
type, \li{ColumnWise} and \li{RowWise}. The suggestions are further informed by
the statistics of other programs that \HazelEnv has encountered.  Here, the
environment has noticed that the programmer tends to prefer column-wise operations on 
matrices, so it marks that suggestion as the most probable. These suggestions are governed by
our fourth specific aim: a \textbf{statistical action suggestion semantics} (Section~\ref{sec:statistics}). The key invariant here that, again, we aim to establish 
formally is that every suggestion assigned non-zero probability must be semantically sensible 
relative to the edit state.% Moreover, all probability distributions must ``integrate'' to $1$.

\vspace{0.25ex}
\noindent\textbf{Roadmap.} Sections~\ref{sec:statics}--\ref{sec:statistics} detail the
specific aims mentioned above; our evaluation plan is discussed in Section~\ref{sec:eval}.
The collaboration plan details our 
research timeline, and the relevant qualifications of the PIs.

% To summarize, 
% the following are the specific aims of the proposed reasearch.

% \begin{enumerate}[labelwidth=0.7em, labelsep=0.6em, topsep=0ex, itemsep=0ex,
%   parsep=0ex]
% \item A static semantics for incomplete programs (Section~\ref{sec:statics}).
% \item A dynamic semantics for incomplete programs (Section~\ref{sec:dynamics}).
% \item An edit action semantics (Section~\ref{sec:actions})
% \item Statistical program inferene semantics (Section~\ref{sec:statistics})
% \item \HazelEnv, an integrated interactive programming environment (Section~\ref{sec:hazel})

% \end{enumerate}

\input{statics}
\input{dynamics}
\input{actions}
\input{statistics}
\input{hazel}



\section{Evaluation}
\label{sec:eval}

We have described our proposed design for \HazelEnv, a interactive programming environment that assigns formal meaning  
to incomplete programs, edit actions, and notions of ``validity'' and
``likelihood'' as they relate to suggestios. We propose a multi-pronged evaluation
strategy: 

\paragraph{Formal Claims.} 
A primary strategy is to evaluate the formal claims that we make by encoding
the system we have designed and proving metatheoretic properties using an
automated theorem prover. For our published preliminary work, we have done so
using the Agda theorem prover~\cite{norell2009dependently}.

\paragraph{Programmer Experiments.} 
%
Beyond \Hazel's formal properties, we will conduct small pilot studies to
evaluate design decisions that may have an impact on programmar productivity. 
%
In each study, programmers will perform a series of software editing 
tasks---fix a bug, add a feature, refactor a program---that dominate 
real-world programming effort. As in~\cite{sunshine14plaiddoc}, 
we will base tasks on common forum postings to enhance external validity. In 
each study, we will isolate a particular feature of \Hazel, and the experimental 
condition will differ from the control condition only in that feature. We will 
likely use ``dummy'' or ``Wizard of Oz''  versions of status quo tooling to 
enable/disable the \HazelEnv-specific features \cite{wizard-of-oz}. We will also use 
a think-aloud protocol~\cite{think-aloud-protocol}, in which participants are 
instructed to continuously verbalize what they are thinking/attempting. This 
method will allow us to understand \textit{why} participants do things in a 
particular way, and to determine the source of participant confusion. Since 
programmer skill varies tremendously, we will use a counterbalanced, 
within-subjects design in which each participant is exposed to both the 
experimental and control conditions. 
The design just outlined has been profitably used in many recent programming 
experiments~\cite{stylos-constructor-params, static-typing-apidoc, benefits-generic-types}.

%We intend to pursue a series of such experiments, the exact details of
%which will depend on the examples we use to evaluate preliminary
%designs and any earlier experiments. 

%% However, our first study is
%% likely to focus on the code completion features
%% of \Hazel. Experimental condition tasks will leverage \Hazel-enabled code
%% completion, while in the control condition code completion will use
%% approaches that are standard in modern industrial IDEs.

\paragraph{Educational experiments.} 
%
PI Hammer teaches Semantic Foundations of Programming Languages (CSCI
5535) each year to graduate students, and will also begin teaching a
similar course to undergraduates, beginning in fall 2017.
%
In this course, students learn about the semantic foundations of types
in terms of inductive language definitions and proofs, eventually
culminating in type systems and interpreter implementations (in ML)
for languages that increasingly resemble ML.
%
Many students begin this course with only a general engineering
background, and without computer science or programming experience.
Especially for these students, \Hazel seems particularly attractive,
since it sidesteps typical hangups for novices (syntax and type
errors), but also gives all students a firm type-theoretic foundation
and a powerful underlying language in which to program: core ML.

PI Hammer currently teaches this course in a conventional fashion.
%
Programming assignments are issued in OCaml, and they are programmed
the traditional way, with text editors and make files, which PI Hammer
demonstrates extensively in class.
%
Since live programming requires running incomplete programs, PI Hammer
demonstrates to the students a methodology of using exceptions to
leave ``holes'' in the program, allowing the rest to type-check and
run.

Once Hazelnut matures into \Hazel, with all the features of core ML,
PI Hammer will supplement and later replace these lectures and
programming assignments in OCaml with ones given in \Hazel.
%
Students will use \Hazel to complete these assignments in place of a
traditional text editor and make file.

\Hazel will provide a
substrate to create interactive tutorials for lecture supplements (or
the lecture itself, e.g., in a flipped classroom); similar tutorials
can also serve as problem sets for homeworks, quizes and tests.
%
Their holes provide places for students to edit and complete the
program; their narrations help explain the problems to solve at each
hole.

Further, the \Hazel action semantics provides a hi-fidelity recording
of every edit action. Currently, PI Hammer demonstrates OCaml
programming tasks by live programming in class using a text editor,
projected on the wall and recorded as videos that the students can
rewatch.  He commits the final, complete program at the conclusion of
lecture to a git repository to which the class has access.
%
In the future, PI Hammer will use \Hazel's tutorial system to record every edit action
and integrate video recordings of the lecture into the documentation,
allowing students to view, inspect and edit the buffer at any point
during the recorded lecture. These tutorials will also be released online as 
open course material. 

We plan to measure the effects of these changes by introducing \Hazel at
different times for different sub-populations of the class.  With
students who consent, we plan to record edit actions that students
make when solving homework assignments and analyze these qualitatively
to better understand how students interact with \Hazel.  We will also
look at student performance on homework and in-class activities using
\Hazel compared to conventional tools and teaching techniques.  To the
extent that performance differs, we will normalize grading standards and
offer learning activities that mitigate any disadvantages students may
experience either in the control group or the \Hazel group.
%
%In each case, we will compare the \Hazel-based approach described in
%this proposal with the ``conventional'' way of doing the act: either
%lecturing with text editing and posting complete programs, or doing
%assignments with text editing and only permitting type-checking,
%compilation and testing of complete programs.

\paragraph{Refining the design of \Hazel.} 
%% Another aspect of the proposed work is refining 
%% the design sketched above based on the results of our empirical studies.  Here 
%% we briefly describe a number of directions for refinement: As our knowledge of 
%% the characteristics of DSLs in the wild grows, we may identify commonalities 
%% that can be used to make implementation of DSLs easier, for example by 
%% providing library support for those commonalities. Understanding the barriers 
%% to using and implementing DSLs may suggest ways of tweaking Wyvern's design, or 
%% providing novel forms of tool support, in order to overcome those barriers.
We plan to refine the design of \Hazel, especially its user interface,
based on the data from the empirical studies described above, and by
gathering informal feedback from students who use the tool.
%
Although the feedback and suggested changes will depend on what we
discover in the empirical studies, we view this as a good thing, both
for the results of this project, and for the trajectory of language
research more generally.  This project intentionally explores the area
of data-driven language design, which we hope will be a promising
technique for language designers in both academia and industry in the
future.

%\clearpage
%\section{Broader Impacts Summary and Education and Outreach Plan}
\vspace{-5px}
\section{Broader Impacts of the Proposed Work}
\label{sec:broaderimpacts}
% bec: This section title is required by the new GPG

%\todo{Everything in this section is good, but we should definitely also mention impact on industry and education if Hazelnut ideas get adopted by IDEs and educational tools, beyond the specific artifacts we plan to develop.  We believe there could be major gains in productivity and reductions in errors.}

%\todo{Another potentially useful broader impact is forming connections between the language theory community and the tool building community.  This mostly affects researchers, but it potentially does so in a way that goes beyond our specific project.}
\paragraph{Bringing Together Language and Tool Researchers.}
Our collaboration unites distinct expertise in
language design (PI~Aldrich); analysis, synthesis, and heuristic search tools for automated program transformations (PI~Le Goues); language design for incremental computing (PI~Hammer); and empirical evaluation of languages and tools (PI~Sunshine).  Because our work applies programming language theory to programming tools (especially editors), it has the potential to spur broader collaborations between these communities.
%
%PIs Hammer and Aldrich have already published a POPL 2017 paper about
%Hazelnut, a preliminary step towards \Hazel, but the remainder of the
%project will benefit from additional community engagement.

To build such connections in the broader research community, we
will seek additional funding to hold an annual workshop that
brings together experts in these related fields along
with members of this project.
%
As a first step, PI Hammer has co-organized (Oct 2016) a Dagstuhl
seminar on ``programming language techniques for incremental and
reactive computing.''
%
The co-organizers of this seminar consist of:
  Sebastian Erdweg (Technische Universit\"at Darmstadt),  
  Shriram Krishamurthi (Brown University),
  and Camil Demetrescu (Sapienza University of Rome).
%
Beyond this international seminar, we will also hold annual domestic events.

\paragraph{Impact on Next-Generation Programming Tools.} 
Achieving the vision outlined above will change how interactive programming tools are designed, much as achievements in programming language theory have had a broad impact on language design. This will ultimately make the job of the programmer easier because future tools informed by \HazelEnv will 1) eliminate malformed edit states and edit states where the editor cannot provide assistance; 2) improve the quality of the assistance offered by combining powerful statistical and semantic techniques; and 3) tighten the ``feedback loop'' between editing and evaluation.
%% \paragraph{Outreach to Practitioners}
%% %
%% PI Hammer has an on-going collaboration with researchers at Mozilla
%% Research, and in particular, members from the Rust and Servo
%% teams: Lars Bergstrom, Alan Jeffrey, Aaron Turon and Niko Matsakis.
%% %
%% (See the attached letter of collaboration from Lars Bergstrom).
%% %
%% Servo, an experimental web browser written in Rust, requires both
%% correctness and speed; as a result, these researchers are particularly
%% interested in both verification and incremental computing~\cite{Servo2015}.
%% %
%% Further, since Servo runs JavaScript, our proposed IVV system has
%% special relevance for extensible scripts running in this browser.
%% %
%% Going forward, we will continue to hold twice-monthly meetings with
%% Lars Bergstrom and Alan Jeffrey, to better understand the challenges
%% of incremental computing in Servo specifically, and web browsers generally.
%% %
%% Currently, Mozilla's flagship browser (Firefox) has 500 million users;
%% if successful, Servo may eventually supplant Firefox as Mozilla's
%% flagship browser, potentially affecting millions of web users.

\paragraph{Undergraduate and High School Research and Outreach}
%
The PIs consistently engage in bringing undergraduates into
the research community, including sending two
undergraduates to the Programming Languages Mentoring Workshop (PLMW)
at POPL over the last few years.  PIs Sunshine and Le~Goues are the PIs on an NSF REU Site
(CCF-1560137) in interdiscplinary Software Engineering, hosted at CMU.  In summer 2016 the REU Site supported 19 students, including 11 women and 4 members of
underrepresented ethnic groups.  PI Le~Goues is also an active mentor for the
the Girls of Steel, the largest all-girls FIRST Robotics
Competition team in the country, in which capacity she will
seek opportunities to introduce our interactive programming tutorials and
research more broadly to the programming subteam. More than three-quarters of the Girls of Steel
alumnae have declared STEM majors as undergraduates.

%%XXX: Update this?
%The reflective
%frameworks that we study in this proposal are exciting to many
%undergraduates, as they underly the newest web and mobile application
%technologies.
% (e.g., SproutCore~\cite{SproutCore} for the web and
%Cocoa~\cite{Cocoa} for iOS/Mac OS X).  We will introduce them to
%cutting-edge research to make development experiences in these
%frameworks better.
%
The University of Colorado Boulder (CU) has a number of resources that
the PIs engage with to reach out to underrepresented groups.  The
Summer Multicultural Access to Research Training (SMART)
Program~\cite{SMARTURL} brings 25 students from institutions
nation-wide to Boulder each summer to engage in in-depth research.
%SMART is partially funded by the University's NSF Alliances for
%Graduate Education and the Professoriate (AGEP) grant.  
The College of Engineering at CU through the Discovery Learning
Apprenticeship (DLA) Program~\cite{DLAURL} partly sponsors stipends to
engage undergraduates in research activity.
%
The PIs will seek additional support for new
undergraduates to participate in the proposed research.

% Moved up because the solicitation said we should have a separate
% "Curriculum Development Activities" section. - Evan

% \paragraph{Integrating Research and Graduate Education
%  in CS and ECEE}

% The PIs teach graduate courses in programming language semantics,
% compiler construction, type systems, and program analysis.  Central to
% each course is a semester project component that encourages student
% engagement in research activities (especially Master's students).  The
% foundational courses are offered through CU's distance education
% program (CAETE), which draws working professionals from industry.  We
% encourage such students to integrate research ideas from these courses
% with the concrete development problems that they have in their jobs.
% In the \emph{Program Analysis} course, students helped create an
% analysis framework for JavaScript and began experimenting with the
% ideas that underly this proposal.
% %
% %course has served as a laboratory for
% %research ideas.  In the first offering of the course, the creation of
% %an analysis framework for JavaScript was begun leading to some ideas
% %that underly this proposal.
% %
% In the \emph{Compiler Construction} course, students build a compiler
% for Python, and several of the final projects have experimented with
% gradual typing and type specialization. One of the female students,
% Neelam Agrawal, did an exceptional job in the course. We intend
% to fund Neelam's Ph.D. work through this project. 
% %
% In addition, the PIs have developed a draft textbook for this course
% that is already being used at other universities.

% The PIs are leading an effort to organize a tight cross-departmental
% collaboration (ECEE and CS) that both seeks to leverage research
% strengths and coordinate a coherent undergraduate and graduate
% curriculum on programming languages, compilers, program analysis, and
% verification.

\paragraph{Curriculum Development Activities}

The PIs teach graduate courses in programming language semantics,
compiler construction and program analysis. Central to each course is
a semester project component that encourages student engagement in
research activities. The foundational
courses at CU are offered through CU's distance education program
(BBA), which draws working professionals from industry. We encourage
such students to integrate research ideas from these courses with the
concrete development problems that they have in their jobs.  This
proposal lends itself to both contributing to the infrastructure of
our undergraduate and graduate courses and providing a test bed for excited students to explore ideas related to this proposal. 

%The PIs have a track record of
%integrating research infrastructure with course infrastructure. For
%example, in a previous offering of \emph{Program Analysis} course,
%students helped create an analysis framework for JavaScript and began
%experimenting with ideas in analyzing dynamic languages.

% \TODO{Sam, your tidbits here?} Nothing here (well, nothing that isn't
% totally boilerplate)

% The PIs are leading an effort to organize a tight cross-departmental
% collaboration (ECEE and CS) that both seeks to leverage research
% strengths and coordinate a coherent undergraduate and graduate
% curriculum on programming languages, compilers, program analysis,
% program synthesis, concurrency, and verification.



%\paragraph{Course-Based Evaluation}
%
%Upon completion of this project, we will seek funding to evaluate the
%applicability of techniques developed here and to find ways to broaden
%the impact on software engineering practice.  PI Cerny teaches a
%graduate, Master's-level course on concurrent programming.  This
%course would be an interesting laboratory for further evaluation.  PI
%Chang has positive prior experience in deploying and evaluating
%program analysis tools in the
%classroom~\citep{DBLP:conf/tldi/ChangCNS05a,Tutch}.
%\TODO{BEC: Will cut this para if we run out of space.}

\vspace{-10px}
\section{Results of Prior NSF Support}

\noindent \textbf{Aldrich} was the PI of the project ``SHF:Small:Foundations of Permission-Based Object-Oriented Languages'' (CCF-1116907, \$500,000, August 2011-July 2015).  \emph{Intellectual Merit:} This project developed a new programming language, Plaid, that incorporated permissions natively into the type system and runtime of the language.  Permissions are type-like annotations that specify how an object may be aliased, and how the various aliases may use the object. Two applications of permissions were demonstrated: 1) the ability to safely change the interface, behavior, and representation of an object at run time and 2) automatic parallelization. This work resulted in 10 major conference or journal publications~
\cite{sunshine11:plaid,
naden12:borrowing,hannesPlural,PradelAPI13,StorkTOPLAS,
nistor14object-propositions,militao14rgprotocols, sunshine14plaiddoc,
garcia14ftop, sunshine15:searching}.
\emph{Broader Impacts:} This grant contributed to the education of 7 Ph.D. 
students, including 2 women, in addition to several undergraduate and masters students.  The grant also supported the development and release of the open-source languages and tools Plural and Plaid \cite{pluraltool,plaidtool}. Plural was used to teach typestate concepts in courses at Carnegie Mellon.

\vspace{0.5ex}
\noindent \textbf{Hammer} is the PI on the ongoing project
``SHF:Small:Collaborative Research:Online Verification-Validation''
(CCF-1619282, total to CU Boulder: \$309,990, September 2016--August
2019).
%
\emph{Intellectual Merit:}
Online Verification Validation (OVV) combines general-purpose
techniques for incremental computation with modern techniques for
program analysis.
%
OVV proposes \emph{progressive verification} (running ``static''
analysis incrementally, at runtime) and \emph{regressive validation}
(rewriting dynamic tests in the program's continuation); using these
techniques, the project seeks to find a middle way between static and
dynamic analysis.
%
%In contrast to OVV, the live programming of \Hazel will respond
%to \emph{program edits}, not program evaluation; Nevertheless, we
%expect that the two problems will share common elements.
%
Thus far, the OVV project has produced a type system for
general-purpose incremental computation~\cite{TypedAdapton2016}, and a
connection to the type systems for gradual
typing~\cite{OVV2016}.
%, similar to \Hazel.
%
\emph{Broader Impacts:} Though the project is still in its early days, it has lead to numerous public talks: a PhD student will present preliminary work at Midwest Verification Day (October 2016); another PhD student (at the University of Maryland) presented their work at a Dagstuhl seminar in October 2016; PI Hammer will present preliminary work at SPLASH 2016.


\vspace{0.5ex}
\noindent\textbf{Le Goues} is a co-PI on the ongoing project
``SHF:Medium:Collaborative Research:Semi and fully automated program repair''
(CCF-1563797, total to CMU: \$411,997, July 2016--June 2020. The preliminary
work was supported by an EAGER project, CCF-1446966, total
to CMU \$95,932; We discuss them together). \emph{Intellectual merit:} The
work extends and uses semantic code search techniques to
automatically improve programs by correctly repairing defects and constructing new
features. Contributions to date include new
benchmarks and principled quality metrics for research in automated defect
repair~\cite{LeGoues15tse,Smith15fse} and a prototype of a semantic
search-based bug repair approach that produces patches of
substantially and measurably higher quality than those produced by previous
techniques~\cite{Ke15ase}.  \emph{Broader Impacts:}  The
project supports three junior Co-PIs, two of whom are female, as well as 2 CMU
Ph.D. students (one of whom is female) and has supported several undergraduates.
Finally, the project contributes to Le Goues's work ongoing work mentoring
the Girls of Steel, the nation's largest all-girls FRC robotics team, on both
practical debugging techniques and outreach on STEM research and careers.

\vspace{0.5ex}
\noindent\textbf{Sunshine} (with Le~Goues) is a co-PI of ``REU Site: Interdisciplinary Software 
Engineering'' (CCF-1560137, February 2016-January 2019). \emph{Intellectual merit:} The REU site 
provides students with training in interdisciplinary software engineering research, including 
understanding the research literature, formulating and refining research questions, developing 
novel solutions to software engineering problems, and applying scientific evaluation methods. 
\emph{Broader Impacts:} A primary goal for the program is to improve the pipeline from college 
to graduate school and from graduate school into faculty positions. The site provides opportunities 
primarily for groups underserved in computing. Last year, we hosted 18 students (from 218 applicants) 
including 11 female, 7 male, and 4 from under-represented ethnic minorities.

%\emph{SHF: Small: Modular Reflection, CCF-1218208, \$250,000, 10/1/12-9/30/16}.
%The goal of this project is to ease the tension between the
%flexibility of reflective features in dynamic programming languages
%and modularity guarantees provided by more static languages.
%\textit{Intellectual Merit:}  This project has generated
%several
%papers at CAV, ECOOP, SAS, and POPL on compositional verification of meta-feature libraries~\cite{DBLP:conf/cav/CoxCS14,DBLP:conf/ecoop/CoxCS13,DBLP:conf/sas/CoxCR14} and the \emph{almost everywhere invariant} verification approach~\cite{coughlin+2013:attacking-imperative,DBLP:conf/popl/CoughlinC14}.  \textit{Broader Impact:} This project supported in part the PhD work of two students, Devin Coughlin and Arlen Cox, and it has led to engagement with Apple and Facebook.

%% \emph{CAREER: Cooperative Program Analysis: Bridging the Gap Between User and Tool Reasoning, CCF-1055066, \$459,584, 6/1/11-5/31/16}. The goals of this project is to create
%% techniques that enable a program analysis tool and its user to
%% cooperate to validate the property of interest.
%% %---transforming magical
%% %black box analyzers of today into transparent reasoning assistants.
%% \textit{Intellectual Merit:} This project has generated several
%% publications at OOPSLA, PLDI, SAS, and VMCAI on goal-directed program analysis of large, object-oriented programs~\cite{DBLP:conf/oopsla/BlackshearCS15,DBLP:conf/pldi/BlackshearCS13,DBLP:conf/sas/BlackshearCSS11} and rich abstract domain combinators for heap properties~\cite{DBLP:conf/sas/LiRC15,DBLP:conf/sas/ToubhansCR14,DBLP:conf/vmcai/ToubhansCR13}.  An invited
%% keynote~\cite{DBLP:conf/vmcai/Chang14} showed our goal-directed approach for heap reachability properties.
%% \textit{Broader Impact:} It is
%% supporting the PhD dissertation work of a student, Sam Blackshear.  The Thresher and Hopper tools
%% developed as part of this project is available on
%% Github, and we have also contributed back to the WALA Analysis
%% Framework.  We have found and reported bugs in open source projects,
%% including a pernicious bug fixed by Google in the core Android
%% libraries.  From his work on this project, Blackshear won a 2014-2015 Facebook Graduate Fellowship and has led to further engagement with Facebook.

%\paragraph{EAGER: Exploratory Research On Gradual Programming, CCF
%  09-39991, 8/1/09-7/31/11, PI: Jeremy G. Siek, co-PI: Bor-Yuh Evan
%  Chang, co-PI: Amer Diwan.}
%The goal of this project was to change the way in which software is
%developed by creating customizable languages, associated tools, and
%methodologies that enable programmers to express exactly what they
%intend: that is, with no semantic gap.  \textit{Intellectual Merit:}
%This short project generated a conference
%publication~\cite{DBLP:conf/issta/CoughlinCDS12} that then later led
%to further NSF funding.
%\textit{Broader Impact:}  This project supported PhD work and has led
%to a position paper that has been cited in a broader funding call.

%% \paragraph{Van Horn}
%% %% \emph{SHF: Small: Behavioral Software Contract Verification,
%% %%   CCF-1218390, 2012--2015, \$400,000}. {\em Intellectual Merit}: This work
%% %% investigate the verification of behavioral software contracts, a
%% %% runtime mechanism for programmer supplied properties.  The work
%% %% provided the first symbolic execution approach for verifying such
%% %% contracts statically and
%% %% compositionally~\cite{dvanhorn:TobinHochstadt2012Higherorder,
%% %%   dvanhorn:Nguyen2014Soft}.  Recently, we contributed the first
%% %% relatively complete counterexample generation method for
%% %% contracts~\cite{dvanhorn:Nguy7877n2015Relatively}.  {\em Broader
%% %%   Impact}: This work has been integrated in the DrRacket pedagogical
%% %% IDE, widely used in dozens of universities,
%% %% high-schools, and middle-schools throughout the world.  The use of
%% %% contract-based verification and counter-example generation fits
%% %% with the pedagogical ``design recipe'' of Felleisen et al.'s
%% %% \emph{How to Design Programs}~\cite{dvanhorn:Felleisen2001How}.

%% \emph{CCF: Computing Innovation Fellows Project, CNS-0937060,
%%   2009--2011, \$267,500}. Van Horn was awarded a CRA Computing
%% Innovation Fellowship from 2009 to 2011.  This work supported Van Horn
%% as a post-doctoral research at Northeastern University, and produced
%% multiple conference and journal
%% papers~\cite{dvanhorn:VanHorn2011Abstracting,dvanhorn:VanHorn2010Abstracting,dvanhorn:Chang2010Evaluating,dvanhorn:Earl2010Pushdown,dvanhorn:Might2010Resolving,dvanhorn:midtgaard-vanhorn-tr09,dvanhorn:VanHorn2012Systematic}.
%% {\em Intellectual Merit}: In this work, Van Horn and his collaborators
%% developed new foundations for the evaluation of lazy languages,
%% disproved the long held belief that inclusion based flow analysis
%% could surpass the ``cubic bottleneck'', and gave a systematic approach
%% to the design and implementation of higher-order flow analysis based
%% on abstract machines.  The latter has lead to a number of new program
%% analyses for properties ranging from space consumption in a lazy
%% language to verification of stack-based security properties by
%% approximating stack-inspection and resulted in a Research Highlight in
%% \emph{CACM}~\cite{dvanhorn:VanHorn2011Abstracting}.  {\em Broader
%%   Impact}: This work has been incorporated in to HP Fortify's
%% commercial program analysis product.  The technical approach is widely
%% taught and has been incorporated into the UMD PhD level course on
%% program analysis and draft textbook.  The material was included in the
%% ``Redex Summer School'' on semantic modeling at the University of
%% Utah in Summer 2015 and a tutorial at POPL, 2016.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\setcounter{page}{1}
\bibliographystyle{plainnat}
\bibliography{hazel_NSF,all.short}%bec.shortmconferences.short,pavol.bib,szg.short.bib,hammer-thesis1,hammer-thesis2,adapton,dvanhorn-local,dvanhorn}


%\clearpage

%% \begin{figure}
%%   \centering
%%   \includegraphics[width=0.55\textwidth]{drawing}
%% \caption{
%%   \textbf{System overview}: Programmers edit code, input data and
%%   specifications, all of which are stored in a central database, along
%%   with past and future versions.
%%   %  
%%   Meanwhile, several tools continually read and write this database: \textbf{Concrete
%%     interpreters} run programs and in the process they modify data and
%%   eventually produce output; importantly, since programs are self-extensible,
%%   \textbf{the concrete interpreter may also edit the program's code}.
%%   %
%%   Admist program changes, \textbf{abstract interpreters} ignore specific inputs and run the
%%   program abstractly, producing universal facts about its execution.
%%   Validators and verifiers check that data and code match their
%%   specifications, respectively.  Amist both program and
%%     programmer-induced changes, \textbf{validators incrementally recheck data},
%%     while \textbf{verifiers incrementally recheck program facts}.  The output of verification and
%%   validation informs programmers, who revise the system's
%%   specification and implementation over time.
%%   \textbf{A general-purpose run-time system for incremental computation (ICRT)} manages the dependencies between the database and the components that read and write its state.  In addition to keeping relevant results consistent with changing data, code and specifications, the ICRT also manages a cache of prior computation, and deals with issues surrounding system-wide memory management.
%% }  
%% \end{figure}
