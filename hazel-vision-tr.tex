% \documentclass{article}
\documentclass[letterpaper,USenglish]{lipics-v2016}
%This is a template for producing LIPIcs articles. 
%See lipics-manual.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
% for section-numbered lemmas etc., use "numberwithinsect"
\def\OPTIONConf{0}%
\def\OPTIONArxiv{0}%
 
\usepackage{microtype}%if unwanted, comment out or use option "draft"

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the recommended bibstyle

% Author macros::begin %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Toward Semantic Foundations for Program Editors
%\footnote{This work was partially supported by someone.}
}
\titlerunning{Toward Semantic Foundations for Program Editors} %optional, in case that the title is too long; the running title should fit into the top page column

%% Please provide for each author the \author and \affil macro, even when authors have the same affiliation, i.e. for each author there needs to be the  \author and \affil macros
\author[1]{Cyrus Omar}
\author[1]{Ian Voysey}
\author[2]{Michael Hilton}
\author[1]{Joshua Sunshine}
\author[1]{Claire Le Goues}
\author[1]{Jonathan Aldrich}
\author[3]{Matthew Hammer}
\affil[1]{Carnegie Mellon University, Pittsburgh, PA, USA\\
  \texttt{\{comar,iev,sunshine,clegoues,aldrich\}@cs.cmu.edu}}
\affil[2]{Oregon State University, Corvallis, OR, USA\\
\texttt{hiltonm@eecs.oregonstate.edu}}
\affil[3]{University of Colorado Boulder, Boulder, CO, USA\\
  \texttt{matthew.hammer@colorado.edu}}

% \affil[2]{Carnegie Mellon University, Pittsburgh, PA, USA\\
%   \texttt{iev@cs.cmu.edu}}
% \affil[3]{Oregon State University, Corvallis, OR, USA\\
%   \texttt{hiltonm@eecs.oregonstate.edu}}
% \affil[4]{Carnegie Mellon University, Pittsburgh, PA, USA\\
%   \texttt{sunshine@cs.cmu.edu}}
% \affil[5]{Carnegie Mellon University, Pittsburgh, PA, USA\\
%   \texttt{clegoues@cs.cmu.edu}}
% \affil[6]{Carnegie Mellon University, Pittsburgh, PA, USA\\
%   \texttt{aldrich@cs.cmu.edu}}
% \affil[7]{University of Colorado Boulder, Boulder, CO, USA\\
%   \texttt{matthew.hammer@colorado.edu}}

\authorrunning{C. Omar, I. Voysey, M. Hilton, J. Sunshine, C. Le Goues, J. Aldrich, and M. Hammer} %mandatory. First: Use abbreviated first/middle names. Second (only in severe cases): Use first author plus 'et. al.'

\Copyright{the authors}%mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/

% \subjclass{Dummy classification -- please refer to \url{http://www.acm.org/about/class/ccs98-html}}% mandatory: Please choose ACM 1998 classifications from http://www.acm.org/about/class/ccs98-html . E.g., cite as "F.1.1 Models of Computation". 
% \keywords{Dummy keyword -- please provide 1--5 keywords}% mandatory: Please provide 1-5 keywords
% Author macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{Summit oN Advances in Programming Languages (SNAPL 2017)}
\EventShortTitle{SNAPL 2017}
\EventAcronym{SNAPL}
\EventYear{2017}
\EventDate{May 7--10, 2017}
\EventLocation{Asilomar, California}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
% Editor-only macros::end %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{etoolbox}
\usepackage{hyperref}

% \usepackage{srcltx}
% \usepackage{goodcharter}
% \usepackage{euler}

% \usepackage{joshuadunfield}
\usepackage{llproof}
%\usepackage{jdproof}
\usepackage{rulelinks}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{lmodern}
\usepackage{anyfontsize}
\usepackage{stmaryrd}
\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}
\usepackage{amsmath,amsthm,amssymb}
\usepackage{thmtools,thm-restate}
\usepackage{todonotes}
\usepackage{enumerate}

% \usepackage[authoryear]{natbib}
% \bibpunct{(}{)}{;}{a}{}{,}

%\mprset{sep=1em}
\def\MathparLineskip{\lineskiplimit=0.9em\lineskip=0.8em plus 0.2em}

\declaretheoremstyle[
  bodyfont=\sl
]{mytheoremstyle}

\lstset{tabsize=2, 
basicstyle=\ttfamily, 
% keywordstyle=\sffamily,
commentstyle=\itshape\ttfamily\color{gray}, 
stringstyle=\ttfamily\color{red},
mathescape=false,escapechar=\#,
numbers=left, numberstyle=\scriptsize\color{gray}\ttfamily, language=ML, moredelim=[il][\sffamily]{?},showspaces=false,showstringspaces=false,xleftmargin=15pt, 
classoffset=0,belowskip=\smallskipamount, aboveskip=\smallskipamount
}
\lstloadlanguages{Java,VBScript,XML,HTML,ML}
\let\li\lstinline

\newcommand{\Hazel}[0]{\textsf{Hazel}}
\newcommand{\HazelEnv}[0]{\Hazel}

\newcommand{\RuleHead}[1]{\text{\raisebox{1em}[0pt]{\ensuremath{\mathsz{\ifnum\OPTIONConf=1 14pt\else 18pt \fi}{#1}}}}~~~~~}

\newcommand{\abort}{\keyword{abort}\xspace}
\newcommand{\xerrs}{\keyword{error}}
\newcommand{\errs}{\;\xerrs}
% \newcommand{\xmatchfailure}{\keyword{match-failure}}
% \newcommand{\matchfailure}{\;\xmatchfailure}
\newcommand{\inj}[1]{\keyword{inj}_{#1}\,}
\newcommand{\Inj}[1]{\inj{#1}}

\newcommand{\rulename}[1]{\text{\normalfont\textsf{#1}}}

\newcommand{\srctyperulename}[1]{\rulename{\textcolor{dDkRed}{S#1}}}
\newcommand{\srcintrorulename}[1]{\srctyperulename{{#1}Intro}}
\newcommand{\srcelimrulename}[1]{\srctyperulename{{#1}Elim}}

\newrulecommand{TAbort}{\targettyperulename{Abort}}

% \newcommand{\subrulename}[1]{\rulename{$\subtype${#1}}}
% \newrulecommand{SubInjDynsum}{\subrulename{Inj$+?$}}
% \newrulecommand{SubDynsumSum}{\subrulename{${+?}{+}$}}
% \newrulecommand{SubRefl}{\subrulename{Refl}}
% \newrulecommand{SubTrans}{\subrulename{Trans}}
% \newrulecommandONE{SubDynsumInj}{\subrulename{${+?}\Inj{#1}$}}

\newcommand{\tytrans}[1]{{|}{#1}{|}}
\newcommand{\ctxtrans}[1]{\tytrans{#1}}

\newcommand{\Rule}[2]{\textsf{#2}}

% \newtheorem{theorem}{Theorem}
\definecolor{Green}{rgb}{0.0, 0.99, 0.0}
\definecolor{light-gray}{rgb}{0.95, 0.95, 0.95}

\begin{document}
\maketitle

\begin{abstract}
% 
Programming language definitions assign formal meaning to {complete}
programs.
%
Programmers, however, spend a substantial amount of time interacting
with \emph{incomplete} programs -- programs with holes, type inconsistencies and binding inconsistencies -- using tools like program editors and
live programming environments (which interleave editing and
evaluation.)
%
Semanticists have done comparatively little to formally characterize 1) the static and dynamic semantics of incomplete programs; 2) the 
actions available to programmers as they edit and inspect incomplete programs; and 3) the behavior of editor services that suggest likely edit actions to the programmer based on semantic information extracted from the incomplete program being edited, and from programs that the system has encountered in the past.% As such, each tool designer has largely been left to develop their own \emph{ad hoc} heuristics. 

%
This paper serves as a vision statement for a research program that seeks to develop these ``missing'' semantic 
foundations. Our hope is that these contributions, which will take the form of a series of simple formal calculi equipped with a clear mechanized metatheory, will guide the design of a variety of current and future interactive programming tools, much as various lambda calculi have guided modern language designs. Our own research will apply these principles in the design of \HazelEnv, an experimental \emph{live lab notebook} programming environment designed for data science tasks. Perhaps controversially, we plan to co-design the \HazelEnv~language with the editor so that we can explore e.g. edit-time semantic conflict resolution mechanisms and mechanisms that allow library providers to install new library-specific edit-time features.

% We propose:
% %
% a \textbf{static semantics for incomplete programs} that assigns static meaning to programs with \emph{holes}, \emph{type inconsistencies}, \emph{binding inconsistencies} and other local, transient problems; 
% %
% a \textbf{dynamic semantics for incomplete programs} that assigns dynamic meaning to incomplete programs and supports ``edit-and-resume'' functionality, thereby tightening the live programming feedback loop;  
% %
% an \textbf{action semantics} that captures the process of editing a program using structured edit actions and maintains a powerful semantic invariant: that every intermediate edit state can be assigned static and dynamic meaning according to the aforementioned semantics for incomplete programs; and 
% %
% a \textbf{statistical action suggestion semantics}, which serves as a foundation for advanced editor features, like semantic code completion and automatic program repair, that need to generate both \emph{semantically valid} and \emph{statistically likely} code snippets and actions.

% To ensure that these individual developments lead toward a coherent
% and practical \emph{theory of interactive programming}, we plan to
% integrate them into a \emph{live lab notebook} programming
% environment, \HazelEnv. By embracing a clean-slate integrative
% approach, we can investigate the semantics of novel constructs that
% are defined within programs but control the programming environment,
% notably \textbf{programmable edit action macros},
% \textbf{type-specific projection macros} and \textbf{semantic,
%   interactive documentation}.

% Although our proposed contributions are primarily {mathematical}, we
% will also conduct small \textbf{pilot studies} involving in order to
% 1) gather data for the action suggestion system; 2) iterate on
% \HazelEnv's design and evaluate whether our ``semantics-first'' tool
% design methodology can scale to produce a tool that allows programmers
% to productively engage in non-trivial (if not yet large-scale)
% programming tasks; and 3) evaluate whether the interactive
% documentation system we have proposed improves tutorial comprehension,
% relative to an approach that relies on non-interactive documentation.

\end{abstract}


\section{Introduction}

% Our research aims to bridge two historically distinct traditions: (1) the formal
% tradition, which has produced seminal advances by viewing programming languages,
% and therefore programs, as mathematical structures~(see e.g. \cite{pfpl,Pierce:2002hj}); and (2) the interaction design
% tradition, which has produced a number of innovative interactive programming
% tools by viewing programming as an interaction between a human programmer and a tool. We borrow from both traditions to propose 

% This paper envisions \Hazel, a clean-slate interactive programming
% environment equipped with a formal semantics that assigns meaning 
% to ``edit-time'' structures and interactions that have largely been 
% considered beyond the scope of the formal tradition to date. Figure~\ref{fig:hazel-mockup} shows a mockup of \HazelEnv's user interface,
% which we will reference throughout our discussion.

%\HazelEnv, like many existing 
Language-aware program editors (e.g. Eclipse
or Emacs, with the appropriate  
extensions installed \cite{gamma2004contributing}) offer programmers a number of useful editor services. Simple examples include (1)
syntax highlighting, (2)
type inspection, (3)
navigation to variable binding sites, and (4)
refactoring. More sophisticated editors provide context-aware suggestions to the programmer (using various code completion, program synthesis and program repair techniques.) Many editors also offer \emph{live programming} services, e.g. by displaying the run-time value of an expression directly within the editor as the program is running. \todo{citations}

When these editor services encounter \emph{complete programs} -- programs that are well-formed and semantically meaningful according to the definition of the language in use -- they can rely on a variety of well-understood reasoning principles and program manipulation techniques. For example, a syntax highlighter for well-formed programs can be generated automatically 
from a context-free grammar \cite{DBLP:conf/tools/KrahnRV08,DBLP:conf/cc/BrandDHJJKKMOSVVV01} and the remaining editor services enumerated above can follow the language's type and binding structure as specified by a standard static
semantics. Live programming services can additionally refer to the language's dynamic semantics.

The problem, of course, is that many of the {edit states} encountered by a program editor do not correspond to complete programs. For example, the programmer may be in the midst of a transient edit, or the programmer may have introduced a type error somewhere in the program. Standard language definitions are silent about incomplete programs, so in these situations, many program editors simply disable various editor services until the program is again in a complete state. In other words, useful editor services become unavailable when the programmer needs them most of all! More advanced editors have developed various \emph{ad hoc} and poorly understood heuristics that attempt to recover from the problem and continue on, using some idiosyncratic internal representation of the incomplete program.

This paper advocates for a research program that seeks to understand incomplete programs, and the editor services that interact with them, as semantically rich mathematical objects. In other words, we seek to broaden the scope of the ``programming language theory'' (PLT) tradition, which has made significant advances by treating complete programs, programming languages and logics as semantically rich mathematical objects. %Indeed, our view is that complete programs should ultimately be understood as ``trivially incomplete'' programs.

In following the PLT tradition, we intend to start by developing a series of minimal calculi that build upon the well-understood typed lambda calculus to capture the essential character of incomplete programs and various editor services of interest. Editor designers can then apply the insights gained from studying these calculi (together with insights gained from the study of human factors and other topics) to design more elaborate program editors. Some of these editors will evolve directly from editors already in use today. At the same time, we plan to design a ``clean-slate'' programming environment, \Hazel, based directly on these first principles. This will allow researchers to cleanly explore the frontier of what is possible when one considers languages and editors within a common theoretical framework. Such a clean-slate design might also prove useful in certain educational settings, and perhaps even make its way into practice.

Figure \ref{fig:hazel-mockup} shows a mockup of the \Hazel ~user interface, which is modeled on the widely adopted IPython / Jupyter lab notebook interface\todo{citation}. We will refer to this figure throughout the remainder of the paper, which briefly summarizes some of the fundamental problems that we must confront as we seek to develop a semantic foundation for advanced program editors. In each section, we discuss existing approaches, including our own recent research, and suggest a number of promising future research directions for the community to pursue.

\paragraph{Problem 1: Syntactically Malformed Edit States.} 
Textual program editors frequently encounter edit states
that are not well-formed with respect to the textual syntax of complete
programs. For example, consider a programmer in the midst of
constructing a call to a function \lstinline{std}: 
\[
\texttt{std(y, }
\]
There is a syntax
error at this moment in the editing process, so editor services that require a syntactically
complete program must be disabled. This is unsatisfying. Sophisticated editors like Eclipse, and editor generators like Spoofax \cite{DBLP:conf/oopsla/KatsV10}, use \emph{error recovery} heuristics that can support the continued provision 
of various services in some formally malformed states, by using secondary notational conventions (e.g. whitespace) to segregate malformed portions of the program  \cite{DBLP:conf/oopsla/KatsJNV09,DBLP:conf/sle/JongeNKV09}. These heuristics work most, but not all, of the time.

The alternative approach that we take for \HazelEnv is to build a
\emph{structure editor} -- a program editor where every edit state
maps onto a syntax tree, with \emph{holes} representing leaves of the tree
that have not yet been constructed.  This representation choice sidesteps the
problem of syntactically malformed edit states. Notice that in
Figure~\ref{fig:hazel-mockup}, the program fragment in cell
\textbf{(a)} contains holes, appearing as squares. This design also permits
non-textual \emph{projections} of expressions, e.g. 
the 2D projection of a matrix value in cell \textbf{(b)}.
We will return to the topic of structure editors and projections below.


\begin{figure}
\includegraphics[width=1.025\textwidth]{mockup-1}
\caption{A mockup of \HazelEnv.}
\label{fig:hazel-mockup}
%\vspace{-2ex}
\end{figure}

\paragraph{Problem 2: Statically Meaningless Edit States.} Regardless of how an 
editor confronts syntactically malformed edit states, it must also confront 
edit states that are syntactically well-formed but statically meaningless. For
example, the following value binding has a type inconsistency:
\begin{lstlisting}[numbers=none]
val x : string = std(m, ColumnWise)
\end{lstlisting}
(because \li{std} has type \li{matrix<float> * dimension -> vec<float>},
but the type annotation on \li{x} is \li{string}.) This leaves the entire program
formally meaningless according to a standard static semantics.

In the presence of holes, the problem of reasoning statically about edit states
becomes even more interesting.  Consider the incomplete expression \lstinline{std(m, #$\square$#)} 
from cell \textbf{(a)} in Figure \ref{fig:hazel-mockup}.
%
%\begin{lstlisting}[numbers=none]
%std(m, #$\square$#)
%\end{lstlisting}
%
Although it is apparent that the type of this expression, after hole instantiation, could only be \lstinline{vec<float>} (the return type of \lstinline{std}),
and that the hole must be instantiated with values of type \li{dimension}, the static
semantics of complete expressions is again silent about these matters. 

Various heuristic
approaches are implemented in Eclipse and other sophisticated tools, but the 
formal character of these heuristics are obscure, buried deep within their implementations. This brings us to our first specific research aim: the 
development, from type-theoretic first principles, of \textbf{a static semantics for incomplete programs} (Section~\ref{sec:statics}),
i.e. programs that contain holes, type inconsistencies, unbound variables, and
other static problems. Using such a semantics, \HazelEnv can 
communicate to the programmer (see right column of Figure \ref{fig:hazel-mockup}) that the expression at the cursor, highlighted in blue in cell \textbf{(a)}, must be of type \li{dimension}. The incomplete function
\li{summary_stats} as a whole will be assigned the following incomplete function
type: \texttt{matrix<float> -> \{ {mean} : vec<float>, std : vec<float>, median :~$\square$ \}}.

\paragraph{Problem 3: Dynamically Meaningless Edit States.} Modern programming
tools are increasingly moving beyond simple ``batch'' programming models by
incorporating \emph{live programming} features that interleave editing and
evaluation \cite{DBLP:conf/icse/Tanimoto13,DBLP:journals/vlc/Tanimoto90,McDirmid:2007:LUL:1297105.1297073}. These tools provide programmers with more rapid feedback about the
dynamic behavior of the program they are editing, or selected portions thereof \cite{McDirmid:2013:ULP:2509578.2509585}. Examples include \emph{lab notebooks},
e.g. the popular IPython/Jupyter~\cite{Perez:2007:ISI:1251563.1251831}, which allow the
programmer to interactively edit and evaluate program fragments organized into a
sequence of cells (an extension of the read-eval-print loop (REPL)); spreadsheets; {live graphics programming environments}, e.g. SuperGlue \cite{McDirmid:2007:LUL:1297105.1297073}, Sketch-n-Sketch \cite{DBLP:conf/pldi/ChughHSA16,DBLP:conf/icse/Chugh25} and the tools demonstrated by Bret Victor in his lectures \cite{victor2012inventing}; the TouchDevelop live UI framework \cite{burckhardt2013s}; and live visual and auditory dataflow languages \cite{DBLP:conf/vl/BurnettAW98}. 
% \item \emph{Live debuggers} allow the programmer to:
%   \begin{itemize}
%   \item insert breakpoints, which pause evaluation; 
%   \item step through evaluation one step at a time; 
%   \item inspect the run-time state of a paused program by ``watching'' expressions; and 
%   \item edit the program and resume evaluation in certain circumstances. 
%   \end{itemize}

Our proposed design for \HazelEnv combines aspects of several of these designs to form a \emph{live lab notebook interface}. 
It will use the edit state of each cell to continuously update the output
value displayed for that cell and subsequent cells that depend on
it. Uniquely, rather than providing meaningful feedback about the dynamic
behavior only once a cell becomes complete, \HazelEnv will provide meaningful feedback also
about the dynamic behavior of incomplete cells (and thereby further tighten the live programming 
feedback loop.)

For example, in cell \textbf{(c)} of Figure~\ref{fig:hazel-mockup}, the
programmer applies  the incomplete function \li{summary_stats} to 
the matrix \lstinline{my_data}, and 
the editor is still able to display a result.
The value of the column-wise mean is fully determined, because evaluation does
not encounter any holes, whereas the standard deviation and median computations
cannot be fully evaluated. Notice, however, that the standard
deviation computation does communicate the substitution of the applied argument,
\li{my_data}, for the variable \li{m}.\footnote{To avoid exposing the internals
of imported library functions, evaluation does not step into functions, like
\li{std}, that have been imported from external libraries indicated by the row at the top of Figure \ref{fig:hazel-mockup} (unless specifically
requested, not shown.)}

This brings us to our second specific aim: a
\textbf{dynamic semantics for incomplete programs} (Section~\ref{sec:dynamics}) that builds upon our proposed
static semantics. There is some precedent for this: research in gradual typing
considers the dynamic semantics of programs with holes in types, and indeed, our
proposed static semantics for incomplete programs borrows technical machinery
from theoretical work on gradual typing~\cite{Siek06a}. We seek a dynamic semantics for the
other classes of incomplete programs that we will consider as well.

This will require great formal care, because the presence of type
and binding errors would violate the usual notions of type safety. As such we plan to develop a \emph{mechanized
  metatheory}~\cite{Lee:2007:TMM:1190216.1190245}: we will use a proof assistant to mechanize the semantics and
accompanying metatheorems that establish essential properties, e.g. that
evaluating a statically meaningful incomplete programs will not ``go wrong'' (which we take in
the sense of Milner to mean that it will not have undefined behavior~\cite{milner1978theory,pfpl}).
This represents the ``gold standard'' for evaluating claims in formal
semantics.  Our preliminary work has used Agda~\cite{norell2009dependently}.

\paragraph{Problem 4: Meaningless Edit Actions.} Our first two specific aims
allow us to assign meaning to intermediate edit states. However, to
understand the act of \emph{editing} itself, we propose to develop a system of
\emph{edit actions} that governs transitions between edit
states. Our goal is for every intermediate edit state to be both statically and
dynamically meaningful according to the semantics developed in the first two
specific aims. This corresponds formally to proving a
metatheorem about the action semantics: when the initial edit state is
semantically meaningful, the edit state that results from performing an action
is as well. In addition to this crucial metatheorem, which
we call \emph{sensibility}, there are a number of other metatheorems of interest
that establish the interactive expressive power of the action semantics. Our third specific
aim is thus to develop a sensible and expressive \textbf{semantics of edit actions} (Section~\ref{sec:actions})
and, as above, to mechanize its metatheory.

Designing the static semantics of \HazelEnv together with its action semantics 
will also allow us to rigorously investigate a number of novel constructs that 
are defined with libraries but control aspects of the editor. In particular, we aim to explore:
(1) \textbf{user-defined action macros}, which allow libraries to define new high-level
actions built atop the primitive action language of \HazelEnv; (2) \textbf{type-specific
projections}, which give library providers the ability to define type-specific structure editors (e.g. the matrix interface in Figure \ref{fig:hazel-mockup}, which is defined  
by the \li{Numerics} library); and (3) an \textbf{interactive semantic documentation system} that
allows programmers to document programs by revealing and commenting on portions of the 
program in sequence. Each intermediate state during these ``tutorials'' can be explored 
by the learner, due to the sensibility invariant. The comments can mention bindings, and are 
subject to static operations like renaming.

\paragraph{Problem 5: Meaningless and Improbable Suggestions.} The simplest 
edit actions will be bound to keyboard shortcuts (studies suggest that programmers experienced with a keyboard-driven structure editors can be highly productive \cite{DBLP:conf/vl/Asenov014}). However, \HazelEnv will 
also present a search-based user
interface for discovering relevant higher-level actions -- marked with \textbf{(d)} in Figure \ref{fig:hazel-mockup}. 
The suggestions 
listed are informed by the semantics at the cursor, i.e. they use the fact that
the type at the cursor is \li{dimension} to suggest the two constructors of that
type, \li{ColumnWise} and \li{RowWise}. The suggestions are further informed by
the statistics of other programs that \HazelEnv has encountered.  Here, the
environment has noticed that the programmer tends to prefer column-wise operations on 
matrices, so it marks that suggestion as the most probable. These suggestions are governed by
our fourth specific aim: a \textbf{statistical action suggestion semantics} (Section~\ref{sec:statistics}). The key invariant here that, again, we aim to establish 
formally is that every suggestion assigned non-zero probability must be semantically sensible 
relative to the edit state.% Moreover, all probability distributions must ``integrate'' to $1$.

\paragraph{Roadmap.} Sections~\ref{sec:statics}--\ref{sec:statistics} detail the
specific aims mentioned above; our evaluation plan is discussed in Section~\ref{sec:eval}.
The collaboration plan details our 
research timeline, and the relevant qualifications of the PIs.

% To summarize, 
% the following are the specific aims of the proposed reasearch.

% \begin{enumerate}[labelwidth=0.7em, labelsep=0.6em, topsep=0ex, itemsep=0ex,
%   parsep=0ex]
% \item A static semantics for incomplete programs (Section~\ref{sec:statics}).
% \item A dynamic semantics for incomplete programs (Section~\ref{sec:dynamics}).
% \item An edit action semantics (Section~\ref{sec:actions})
% \item Statistical program inferene semantics (Section~\ref{sec:statistics})
% \item \HazelEnv, an integrated interactive programming environment (Section~\ref{sec:hazel})

% \end{enumerate}

\input{macros-popl17}
\input{statics}
\input{dynamics}
\input{actions}
\input{statistics}
\input{hazel}



\section{Proposed Evaluation}
\label{sec:eval}

We have described our proposed design for \HazelEnv, a interactive programming environment that assigns formal meaning  
to incomplete programs, edit actions, and notions of ``validity'' and
``likelihood'' as they relate to suggestios. We propose a multi-pronged evaluation
strategy: 

\paragraph{Formal Claims.} 
A primary strategy is to evaluate the formal claims that we make by encoding
the system we have designed and proving metatheoretic properties using an
automated theorem prover. For our published preliminary work, we have done so
using the Agda theorem prover~\cite{norell2009dependently}.

\paragraph{Programmer Experiments.} 
%
Beyond \Hazel's formal properties, we will conduct small pilot studies to
evaluate design decisions that may have an impact on programmar productivity. 
%
In each study, programmers will perform a series of software editing 
tasks---fix a bug, add a feature, refactor a program---that dominate 
real-world programming effort. As in~\cite{sunshine14plaiddoc}, 
we will base tasks on common forum postings to enhance external validity. In 
each study, we will isolate a particular feature of \Hazel, and the experimental 
condition will differ from the control condition only in that feature. We will 
likely use ``dummy'' or ``Wizard of Oz''  versions of status quo tooling to 
enable/disable the \HazelEnv-specific features \cite{wizard-of-oz}. We will also use 
a think-aloud protocol~\cite{think-aloud-protocol}, in which participants are 
instructed to continuously verbalize what they are thinking/attempting. This 
method will allow us to understand \textit{why} participants do things in a 
particular way, and to determine the source of participant confusion. Since 
programmer skill varies tremendously, we will use a counterbalanced, 
within-subjects design in which each participant is exposed to both the 
experimental and control conditions. 
The design just outlined has been profitably used in many recent programming 
experiments~\cite{stylos-constructor-params, static-typing-apidoc, benefits-generic-types}.

%We intend to pursue a series of such experiments, the exact details of
%which will depend on the examples we use to evaluate preliminary
%designs and any earlier experiments. 

%% However, our first study is
%% likely to focus on the code completion features
%% of \Hazel. Experimental condition tasks will leverage \Hazel-enabled code
%% completion, while in the control condition code completion will use
%% approaches that are standard in modern industrial IDEs.

\paragraph{Educational experiments.} 
%
PI Hammer teaches Semantic Foundations of Programming Languages (CSCI
5535) each year to graduate students, and will also begin teaching a
similar course to undergraduates, beginning in fall 2017.
%
In this course, students learn about the semantic foundations of types
in terms of inductive language definitions and proofs, eventually
culminating in type systems and interpreter implementations (in ML)
for languages that increasingly resemble ML.
%
Many students begin this course with only a general engineering
background, and without computer science or programming experience.
Especially for these students, \Hazel seems particularly attractive,
since it sidesteps typical hangups for novices (syntax and type
errors), but also gives all students a firm type-theoretic foundation
and a powerful underlying language in which to program: core ML.

PI Hammer currently teaches this course in a conventional fashion.
%
Programming assignments are issued in OCaml, and they are programmed
the traditional way, with text editors and make files, which PI Hammer
demonstrates extensively in class.
%
Since live programming requires running incomplete programs, PI Hammer
demonstrates to the students a methodology of using exceptions to
leave ``holes'' in the program, allowing the rest to type-check and
run.

Once Hazelnut matures into \Hazel, with all the features of core ML,
PI Hammer will supplement and later replace these lectures and
programming assignments in OCaml with ones given in \Hazel.
%
Students will use \Hazel to complete these assignments in place of a
traditional text editor and make file.

\Hazel will provide a
substrate to create interactive tutorials for lecture supplements (or
the lecture itself, e.g., in a flipped classroom); similar tutorials
can also serve as problem sets for homeworks, quizes and tests.
%
Their holes provide places for students to edit and complete the
program; their narrations help explain the problems to solve at each
hole.

Further, the \Hazel action semantics provides a hi-fidelity recording
of every edit action. Currently, PI Hammer demonstrates OCaml
programming tasks by live programming in class using a text editor,
projected on the wall and recorded as videos that the students can
rewatch.  He commits the final, complete program at the conclusion of
lecture to a git repository to which the class has access.
%
In the future, PI Hammer will use \Hazel's tutorial system to record every edit action
and integrate video recordings of the lecture into the documentation,
allowing students to view, inspect and edit the buffer at any point
during the recorded lecture. These tutorials will also be released online as 
open course material. 

We plan to measure the effects of these changes by introducing \Hazel at
different times for different sub-populations of the class.  With
students who consent, we plan to record edit actions that students
make when solving homework assignments and analyze these qualitatively
to better understand how students interact with \Hazel.  We will also
look at student performance on homework and in-class activities using
\Hazel compared to conventional tools and teaching techniques.  To the
extent that performance differs, we will normalize grading standards and
offer learning activities that mitigate any disadvantages students may
experience either in the control group or the \Hazel group.
%
%In each case, we will compare the \Hazel-based approach described in
%this proposal with the ``conventional'' way of doing the act: either
%lecturing with text editing and posting complete programs, or doing
%assignments with text editing and only permitting type-checking,
%compilation and testing of complete programs.

\paragraph{Refining the design of \Hazel.} 
%% Another aspect of the proposed work is refining 
%% the design sketched above based on the results of our empirical studies.  Here 
%% we briefly describe a number of directions for refinement: As our knowledge of 
%% the characteristics of DSLs in the wild grows, we may identify commonalities 
%% that can be used to make implementation of DSLs easier, for example by 
%% providing library support for those commonalities. Understanding the barriers 
%% to using and implementing DSLs may suggest ways of tweaking Wyvern's design, or 
%% providing novel forms of tool support, in order to overcome those barriers.
We plan to refine the design of \Hazel, especially its user interface,
based on the data from the empirical studies described above, and by
gathering informal feedback from students who use the tool.
%
Although the feedback and suggested changes will depend on what we
discover in the empirical studies, we view this as a good thing, both
for the results of this project, and for the trajectory of language
research more generally.  This project intentionally explores the area
of data-driven language design, which we hope will be a promising
technique for language designers in both academia and industry in the
future.



\bibliographystyle{plainnat}

\bibliography{hazel_NSF,all.short}

\appendix

\end{document}


% Local Variables: 
% mode: latex
% TeX-master: "types"
% End: 
